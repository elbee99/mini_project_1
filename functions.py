import matplotlib.animation as animation
import os
import re
from classes import ImageData
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from yellowbrick.cluster import KElbowVisualizer
from nanofilm.ndimage import imread


def relative_growth_rate(image_before : ImageData, image_after : ImageData):
    """
    Plot an image of growth rates for different pixels
    Args:
        image1 (ImageData): One object of ImageData at a given time 
        image2 (ImageData): Object of ImageData at a later time
    """
    thickness_change = image_after.array - image_before.array
    fig, ax = plt.subplots()
    pos = ax.imshow(thickness_change)
    fig.colorbar(pos)



# set this to the path to your installation of FFmpeg
plt.rcParams['animation.ffmpeg_path'] ='C:\\ffmpeg\\bin\\ffmpeg.exe'

def thickness_movie(data_list : list,max_thickness : int or float= None,
                    saveas : str = None):
    """
    This takes in a list of strings of paths to thickness PNG files generated by
    Accurion model fitting, and creates a movie out of them

    Args:
        data_list (list): This is a list of tuples of (accurion_png_path,oxidation_time)

        max_thickness (intorfloat, optional): Largest thickness value
        desired on the colorbar. Defaults to None. If None will use max of array

        saveas (str, optional): relative or absolute path to where .mp4 should be 
        saved. Defaults to None. If None will not save image
    """
    fig, ax = plt.subplots() # generates matplotlib figure
    
    # list of matplotlib Artist objects (I think) with both a matplotlib image
    # object and a matplotlib text object orientated in the location the title
    # would be, updating the text with the different 
    im_list = [[ImageData(path,time).return_image(ax) ,    ax.text(0.5, 1.05, 
                "Oxidation time: {} min".format(time),
                # bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 5},
                transform=ax.transAxes, ha="center")] for path,time in data_list]

    # if max_thickness is defined changes the colorbar limit to match that
    if type(max_thickness) == float or type(max_thickness) == int: 
        for im in im_list:
            im[0].set_clim(0,max_thickness)

    # creates the movie
    ani = animation.ArtistAnimation(fig, im_list, interval=1000, blit=True,
                                    repeat_delay=1000)

    # creates the colorbar
    plt.colorbar(im_list[-1][0])


    # if saveas is defined, saves to the path here using FFMpeg
    if type(saveas) == str:
        writer = animation.FFMpegWriter(
            fps=1, metadata=dict(artist='Larry Brazel'), bitrate=1800)
    
        ani.save(saveas, writer=writer)



def generate_data_list(folder_path : str):
    """
    Generates a list of Accurion data .png file paths and times as specified in
    the file name in a given folder
    Args:
        folder_path (str): str of path to folder containing data

    Returns:
        _type_: _description_
    """
    walk_list = os.listdir(folder_path) # returns all items in folder at folder_path
    accurion_path_list = []
    for item in walk_list:
        # checks if the last characters match those of the Accurion fitted data files
        if item[-6:] == "03.png":
            # uses regex to find the instance of JUST numbers enclosed in two underscores
            match_obj = re.findall("_[0-9]+_",item)
            match_str = match_obj[0] # gets the string of the match
            # print(match_str)
            time = int(match_str[1:-1]) #removes _ and converts to int

            accurion_path_list.append((os.path.join(folder_path,item),time))
    
    #sorts list based off time

    # sorts the list in ascending order of time and returns
    return sorted(accurion_path_list, key = lambda x: x[1])

def image_to_X(image_path : str):
    image_array = imread(image_path)
    return image_array.reshape(np.shape(image_array)[0]*np.shape(image_array)[1],1)

image_path_1470min = r"C:\Users\lb958\Data\2022_12_16_Cu_in_air_run_02\maps\thickness_maps\Cu_50C_0_run01_003.png"

def get_im_width(image_path : str):
    image_array = imread(image_path)
    return np.shape(image_array)[1]

def get_im_height(image_path : str):
    image_array = imread(image_path)
    return np.shape(image_array)[0]

def X_to_image(image_data : np.ndarray,image_path : str):
    width = get_im_width(image_path)
    height = get_im_height(image_path)
    return np.reshape(image_data,[height,width,1])

def segment_image(image_path, n_clusters):

    image_data = image_to_X(image_path)
    km = KMeans(n_clusters = n_clusters)
    km.fit(image_data)
    X_km = km.cluster_centers_[km.predict(image_data)]
    X_km = X_km.astype("uint8")

    img_km = X_to_image(X_km,image_path)
    plt.imshow(img_km)
    plt.show()

def plot_optimal_k(image_path):
    image_data = image_to_X(image_path)
    km = KMeans()
    visualizer = KElbowVisualizer(km,k=(2,20))
    visualizer.fit(image_data)
    visualizer.show()