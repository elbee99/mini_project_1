import matplotlib.animation as animation
import os
import re
from classes import ImageData
import matplotlib.pyplot as plt

def relative_growth_rate(image_before : ImageData, image_after : ImageData):
    """
    Plot an image of growth rates for different pixels
    Args:
        image1 (ImageData): One object of ImageData at a given time 
        image2 (ImageData): Object of ImageData at a later time
    """
    thickness_change = image_after.array - image_before.array
    fig, ax = plt.subplots()
    pos = ax.imshow(thickness_change)
    fig.colorbar(pos)



# set this to the path to your installation of FFmpeg
plt.rcParams['animation.ffmpeg_path'] ='C:\\ffmpeg\\bin\\ffmpeg.exe'

def thickness_movie(data_list : list,max_thickness : int or float= None,
                    saveas : str = None):
    """
    This takes in a list of strings of paths to thickness PNG files generated by
    Accurion model fitting, and creates a movie out of them

    Args:
        data_list (list): This is a list of tuples of (accurion_png_path,oxidation_time)

        max_thickness (intorfloat, optional): Largest thickness value
        desired on the colorbar. Defaults to None. If None will use max of array

        saveas (str, optional): relative or absolute path to where .mp4 should be 
        saved. Defaults to None. If None will not save image
    """
    fig, ax = plt.subplots() # generates matplotlib figure
    
    # list of matplotlib Artist objects (I think) with both a matplotlib image
    # object and a matplotlib text object orientated in the location the title
    # would be, updating the text with the different 
    im_list = [[ImageData(path,time).return_image(ax) ,    ax.text(0.5, 1.05, 
                "Oxidation time: {} min".format(time),
                # bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 5},
                transform=ax.transAxes, ha="center")] for path,time in data_list]

    # if max_thickness is defined changes the colorbar limit to match that
    if type(max_thickness) == float or type(max_thickness) == int: 
        for im in im_list:
            im[0].set_clim(0,max_thickness)

    # creates the movie
    ani = animation.ArtistAnimation(fig, im_list, interval=1000, blit=True,
                                    repeat_delay=1000)

    # creates the colorbar
    plt.colorbar(im_list[-1][0])


    # if saveas is defined, saves to the path here using FFMpeg
    if type(saveas) == str:
        writer = animation.FFMpegWriter(
            fps=1, metadata=dict(artist='Larry Brazel'), bitrate=1800)
    
        ani.save(saveas, writer=writer)



def generate_data_list(folder_path : str):
    """
    Generates a list of Accurion data .png file paths and times as specified in
    the file name in a given folder
    Args:
        folder_path (str): str of path to folder containing data

    Returns:
        _type_: _description_
    """
    walk_list = os.listdir(folder_path) # returns all items in folder at folder_path
    accurion_path_list = []
    for item in walk_list:
        # checks if the last characters match those of the Accurion fitted data files
        if item[-6:] == "03.png":
            # uses regex to find the instance of JUST numbers enclosed in two underscores
            match_obj = re.findall("_[0-9]+_",item)
            match_str = match_obj[0] # gets the string of the match
            # print(match_str)
            time = int(match_str[1:-1]) #removes _ and converts to int

            accurion_path_list.append((os.path.join(folder_path,item),time))
    
    #sorts list based off time

    # sorts the list in ascending order of time and returns
    return sorted(accurion_path_list, key = lambda x: x[1])